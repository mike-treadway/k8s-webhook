#!/usr/bin/env sh

set -e

# default values
svc="newrelic-webhook-svc"

usage() {
  cat <<EOF
Generate certificate signing request suitable for use with New Relic Mutating Webhook.
The server key/cert k8s CA cert are stored in a k8s secret.
usage: ${0} [OPTIONS]

Supported options are:
    --help               [Optional] Display this help message.
    --key <path>         [Optional] Path for a key to the create the certificate in PEM format. Def: autogenerated.
    --namespace <ns>     [Optional] Namespace for the webhook and secret. Def: default.
EOF
  exit 1
}

# arguments
ns="default"
keyFile=""
if [ "$1" == "--key" ]; then
    keyFile="$2"
    if [ "$3" == "--namespace" ]; then
        ns="$4"
    fi
fi
if [ "$1" == "--namespace" ]; then
    ns="$2"
    if [ "$3" == "--key" ]; then
        keyFile="$4"
    fi
fi

# input validation
[[ "$1" != "--help" ]] || usage
if [[ "${ns}" == "" ]]; then
    echo "ERROR: namespace cannot be empty"
    exit 1
fi

if [[ ! -x "$(command -v openssl)" ]]; then
  echo "ERROR: openssl not found"
  exit 1
fi

csr="${svc}.${ns}"

# ephemeral files folder
tmpdir=$(mktemp -d)
echo "INFO: creating certificate files in tmpdir ${tmpdir} "

# generate key when not provided
if [[ "$keyFile" == "" ]]; then
    keyFile="${tmpdir}/server-key.pem"
    openssl genrsa -out ${keyFile} 2048
fi

# generate CSR
cat <<EOF >> "${tmpdir}/csr.conf"
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = ${svc}
DNS.2 = ${svc}.${ns}
DNS.3 = ${svc}.${ns}.svc
EOF

openssl req -new -key "${keyFile}" -subj "/CN=${svc}.${ns}.svc" -out "${tmpdir}/server.csr" -config "${tmpdir}/csr.conf"

set +e
# clean-up any previously stored CSR for our service. Ignore errors if not present.
if kubectl delete csr "${csr}"; then
    echo "WARN: previous CSR was found and removed"
fi
set -e

# create server cert/key CSR and send it to k8s api
cat <<EOF | kubectl create -f -
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: ${csr}
spec:
  groups:
  - system:authenticated
  request: $(base64 < "${tmpdir}/server.csr" | tr -d '\n')
  usages:
  - digital signature
  - key encipherment
  - server auth
EOF

cat << EOF

K8s CSR:  ${csr}
Key file: ${keyFile}

Remaining steps:
Approve CSR:                    kubectl certificate approve "${csr}"
Sign and install certiticate:   cert/generate_certificate.sh ${keyFile}

EOF
